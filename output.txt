4K Matrix Agent Grid Search Test
===================================
Matrix: 4096x4096 (16,777,216 elements)
Hardware: 8 dies, 1024 TFLOPS total
Testing 4x4 split configuration...
[递归 0] 开始处理矩阵: 4096x4096x1
  可用计算单元: ['die_0', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7']
  计算单元数量: 8
  尝试分割配置 1: 2x2 (行x列)
    生成了 4 个 tiles，8 个计算单元
    Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 64
    找到更好的配置，延迟: 64
  尝试分割配置 2: 2x3 (行x列)
    生成了 6 个 tiles，8 个计算单元
    Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 47
    找到更好的配置，延迟: 47
  尝试分割配置 3: 2x4 (行x列)
    生成了 8 个 tiles，8 个计算单元
    Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 40
    找到更好的配置，延迟: 40
  尝试分割配置 4: 3x2 (行x列)
    生成了 6 个 tiles，8 个计算单元
    Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 47
    配置有效，延迟: 47
  尝试分割配置 5: 3x3 (行x列)
    生成了 9 个 tiles，8 个计算单元
    轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
    剩余 1 个 tiles 需要递归处理
    构建了 1 个尾部子区域
    处理子区域 1: [2731:4096, 2731:4096, 0:1]
  [递归 1] 开始处理矩阵: 1365x1365x1
    可用计算单元: ['die_0', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7']
    计算单元数量: 8
    尝试分割配置 1: 2x2 (行x列)
      生成了 4 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 13
      找到更好的配置，延迟: 13
    尝试分割配置 2: 2x3 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 10
      找到更好的配置，延迟: 10
    尝试分割配置 3: 2x4 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 8
      找到更好的配置，延迟: 8
    尝试分割配置 4: 3x2 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 10
      配置有效，延迟: 10
    尝试分割配置 5: 3x3 (行x列)
      生成了 9 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 1 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 10
      配置有效，延迟: 10
    尝试分割配置 6: 3x4 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 9
      配置有效，延迟: 9
    尝试分割配置 7: 4x2 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 8
      配置有效，延迟: 8
    尝试分割配置 8: 4x3 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 9
      配置有效，延迟: 9
    尝试分割配置 9: 4x4 (行x列)
      生成了 16 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 2 个 tiles，总共分配 16 个
      没有剩余 tiles，完成分配
Total running cycles: 6
      找到更好的配置，延迟: 6
  [递归 1] 完成，最佳延迟: 6
Total running cycles: 38
    找到更好的配置，延迟: 38
  尝试分割配置 6: 3x4 (行x列)
    生成了 12 个 tiles，8 个计算单元
    轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
    剩余 4 个 tiles 需要递归处理
    构建了 1 个尾部子区域
    处理子区域 1: [2731:4096, 0:4096, 0:1]
  [递归 1] 开始处理矩阵: 1365x4096x1
    可用计算单元: ['die_0', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7']
    计算单元数量: 8
    尝试分割配置 1: 2x2 (行x列)
      生成了 4 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 31
      找到更好的配置，延迟: 31
    尝试分割配置 2: 2x3 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 22
      找到更好的配置，延迟: 22
    尝试分割配置 3: 2x4 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 18
      找到更好的配置，延迟: 18
    尝试分割配置 4: 3x2 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 26
      配置有效，延迟: 26
    尝试分割配置 5: 3x3 (行x列)
      生成了 9 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 1 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 27
      配置有效，延迟: 27
    尝试分割配置 6: 3x4 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 22
      配置有效，延迟: 22
    尝试分割配置 7: 4x2 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 23
      配置有效，延迟: 23
    尝试分割配置 8: 4x3 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 25
      配置有效，延迟: 25
    尝试分割配置 9: 4x4 (行x列)
      生成了 16 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 2 个 tiles，总共分配 16 个
      没有剩余 tiles，完成分配
Total running cycles: 20
      配置有效，延迟: 20
  [递归 1] 完成，最佳延迟: 18
Total running cycles: 36
    找到更好的配置，延迟: 36
  尝试分割配置 7: 4x2 (行x列)
    生成了 8 个 tiles，8 个计算单元
    Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 40
    配置有效，延迟: 40
  尝试分割配置 8: 4x3 (行x列)
    生成了 12 个 tiles，8 个计算单元
    轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
    剩余 4 个 tiles 需要递归处理
    构建了 2 个尾部子区域
    处理子区域 1: [2048:3072, 2731:4096, 0:1]
  [递归 1] 开始处理矩阵: 1024x1365x1
    可用计算单元: ['die_0', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7']
    计算单元数量: 8
    尝试分割配置 1: 2x2 (行x列)
      生成了 4 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 11
      找到更好的配置，延迟: 11
    尝试分割配置 2: 2x3 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 8
      找到更好的配置，延迟: 8
    尝试分割配置 3: 2x4 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 7
      找到更好的配置，延迟: 7
    尝试分割配置 4: 3x2 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 8
      配置有效，延迟: 8
    尝试分割配置 5: 3x3 (行x列)
      生成了 9 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 1 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 9
      配置有效，延迟: 9
    尝试分割配置 6: 3x4 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 6
      找到更好的配置，延迟: 6
    尝试分割配置 7: 4x2 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 8
      配置有效，延迟: 8
    尝试分割配置 8: 4x3 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 8
      配置有效，延迟: 8
    尝试分割配置 9: 4x4 (行x列)
      生成了 16 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 2 个 tiles，总共分配 16 个
      没有剩余 tiles，完成分配
Total running cycles: 6
      配置有效，延迟: 6
  [递归 1] 完成，最佳延迟: 6
    处理子区域 2: [3072:4096, 0:4096, 0:1]
  [递归 1] 开始处理矩阵: 1024x4096x1
    可用计算单元: ['die_0', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7']
    计算单元数量: 8
    尝试分割配置 1: 2x2 (行x列)
      生成了 4 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 28
      找到更好的配置，延迟: 28
    尝试分割配置 2: 2x3 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 19
      找到更好的配置，延迟: 19
    尝试分割配置 3: 2x4 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 16
      找到更好的配置，延迟: 16
    尝试分割配置 4: 3x2 (行x列)
      生成了 6 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 23
      配置有效，延迟: 23
    尝试分割配置 5: 3x3 (行x列)
      生成了 9 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 1 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 25
      配置有效，延迟: 25
    尝试分割配置 6: 3x4 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 20
      配置有效，延迟: 20
    尝试分割配置 7: 4x2 (行x列)
      生成了 8 个 tiles，8 个计算单元
      Tiles数量 <= 计算单元数量，直接分配
Total running cycles: 22
      配置有效，延迟: 22
    尝试分割配置 8: 4x3 (行x列)
      生成了 12 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 1 个 tiles，总共分配 8 个
      剩余 4 个 tiles 需要递归处理
      达到最大递归深度限制 (1)，使用轮询分配回退策略
Total running cycles: 24
      配置有效，延迟: 24
    尝试分割配置 9: 4x4 (行x列)
      生成了 16 个 tiles，8 个计算单元
      轮询分配: 每个计算单元 2 个 tiles，总共分配 16 个
      没有剩余 tiles，完成分配
Total running cycles: 20
      配置有效，延迟: 20
  [递归 1] 完成，最佳延迟: 16
Total running cycles: 40
    配置有效，延迟: 40
  尝试分割配置 9: 4x4 (行x列)
    生成了 16 个 tiles，8 个计算单元
    轮询分配: 每个计算单元 2 个 tiles，总共分配 16 个
    没有剩余 tiles，完成分配
Total running cycles: 32
    找到更好的配置，延迟: 32
[递归 0] 完成，最佳延迟: 32

✅ 4K Matrix Mapping Found!
Execution latency: 32 cycles
Compute utilization: 51.20%
Matrix operations: 16,777,216
Total compute power: 1,024,000 GOPS

📊 Workload Distribution:
  die_0: 2 tiles, 2,097,152 volume
  die_1: 2 tiles, 2,097,152 volume
  die_2: 2 tiles, 2,097,152 volume
  die_3: 2 tiles, 2,097,152 volume
  die_4: 2 tiles, 2,097,152 volume
  die_5: 2 tiles, 2,097,152 volume
  die_6: 2 tiles, 2,097,152 volume
  die_7: 2 tiles, 2,097,152 volume

🔍 Detailed Tile Shapes:
  die_0 (2 tiles):
    Tile 0: [0:1024, 0:1024, 0:1] -> 1024×1024×1
    Tile 1: [2048:3072, 0:1024, 0:1] -> 1024×1024×1

  die_1 (2 tiles):
    Tile 0: [0:1024, 1024:2048, 0:1] -> 1024×1024×1
    Tile 1: [2048:3072, 1024:2048, 0:1] -> 1024×1024×1

  die_2 (2 tiles):
    Tile 0: [0:1024, 2048:3072, 0:1] -> 1024×1024×1
    Tile 1: [2048:3072, 2048:3072, 0:1] -> 1024×1024×1

  die_3 (2 tiles):
    Tile 0: [0:1024, 3072:4096, 0:1] -> 1024×1024×1
    Tile 1: [2048:3072, 3072:4096, 0:1] -> 1024×1024×1

  die_4 (2 tiles):
    Tile 0: [1024:2048, 0:1024, 0:1] -> 1024×1024×1
    Tile 1: [3072:4096, 0:1024, 0:1] -> 1024×1024×1

  die_5 (2 tiles):
    Tile 0: [1024:2048, 1024:2048, 0:1] -> 1024×1024×1
    Tile 1: [3072:4096, 1024:2048, 0:1] -> 1024×1024×1

  die_6 (2 tiles):
    Tile 0: [1024:2048, 2048:3072, 0:1] -> 1024×1024×1
    Tile 1: [3072:4096, 2048:3072, 0:1] -> 1024×1024×1

  die_7 (2 tiles):
    Tile 0: [1024:2048, 3072:4096, 0:1] -> 1024×1024×1
    Tile 1: [3072:4096, 3072:4096, 0:1] -> 1024×1024×1


⚖️  Load Balance:
  Perfect balance ratio: 1.000
  Load imbalance: 0.0%

🔍 Algorithm Performance:
  Configurations tested: 1
  Cache entries: 5
